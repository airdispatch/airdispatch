package framework

import (
	"airdispat.ch/airdispatch"
	"airdispat.ch/common"
	"bytes"
	"code.google.com/p/goprotobuf/proto"
	"errors"
	"net"
)

// A structure that stores any errors generated by the Server framework
type ServerError struct {
	Location string
	Error    error
}

// This interface defines the functions that an
// Airdispatch server must respond to in order to properly function
type ServerDelegate interface {
	HandleError(err *ServerError)
	LogMessage(toLog string)

	SavePublicMail(theMessage *common.ADMail)
	SavePrivateMail(theMessage *common.ADMail, toAddr []string) (messageId string)

	SaveIncomingAlert(alert *common.ADAlert)

	AllowSendConnection(fromAddr *common.ADAddress) bool

	RetrieveMessageForUser(id string, addr *common.ADAddress) (message *common.ADMail)
	RetrievePublic(fromAddr *common.ADAddress, since uint64) (messages []*common.ADMail)
	RetrieveInbox(addr *common.ADAddress, since uint64) (messages []*common.ADAlert)
}

// The server structure tahat holds all of the necessary instance variables
type Server struct {
	LocationName string
	TrackerList  *common.ADTrackerList
	Key          *common.ADKey
	Delegate     ServerDelegate
}

// Function that starts the server on a specific port
func (s *Server) StartServer(port string) error {
	// Resolve the Address of the Server
	service := ":" + port
	tcpAddr, _ := net.ResolveTCPAddr("tcp4", service)
	s.Delegate.LogMessage("Starting Server on " + service)

	// Start the Server
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		return err
	}
	s.Delegate.LogMessage("Server is Running...")

	s.serverLoop(listener)
	return nil
}

// Sends an error to the Server Delegate
func (s *Server) handleError(location string, error error) {
	s.Delegate.HandleError(&ServerError{
		Location: location,
		Error:    error,
	})
}

// The loop that continues while waiting on clients to connect
func (s *Server) serverLoop(listener *net.TCPListener) {
	// Loop forever, waiting for connections
	for {
		// Accept a Connection
		conn, err := listener.Accept()
		if err != nil {
			s.handleError("Server Loop (Accepting New Client)", err)
			continue
		}

		// Concurrently handle the connection
		go s.handleClient(conn)
	}
}

// Called when a client connects
func (s *Server) handleClient(conn net.Conn) {
	// Close the Connection after Handling
	defer conn.Close()

	// Read in the Message
	newMessage, err := common.CreateADMessageFromConnection(conn)
	if err != nil {
		s.handleError("Handle Client (Reading Signed Message)", err)
		return
	}

	// Switch based on the Message Type
	switch newMessage.MessageType {

	case common.ALERT_MESSAGE:
		alert, err := common.CreateADAlertFromADMessage(newMessage)
		if err != nil {
			s.handleError("Handle Client (Reading ADAlert)", err)
		}

		s.Delegate.SaveIncomingAlert(alert)

	case common.RETRIEVAL_MESSAGE:
		s.handleRetrieval(newMessage, conn)

	case common.SEND_REQUEST:

		if !s.Delegate.AllowSendConnection(newMessage.FromAddress) {
			return
		}

		// Unmarshal the stored message
		assigned := &airdispatch.SendMailRequest{}
		err := proto.Unmarshal(newMessage.Payload, assigned)
		if err != nil {
			s.handleError("Handle Client (Unloading Send Request Payload)", err)
			return
		}

		// Handle the Send Request
		s.handleSendRequest(assigned, newMessage.FromAddress)
	}
}

// Function that Handles a DataRetrieval Message
func (s *Server) handleRetrieval(retrievalMessage *common.ADMessage, conn net.Conn) {

	retrieval := &airdispatch.RetrieveData{}
	err := proto.Unmarshal(retrievalMessage.Payload, retrieval)
	if err != nil {
		s.handleError("Handle Client (Unloading Retrieval Payload)", err)
		return
	}

	// Get the Type of the Message and Switch on it
	c := retrieval.RetrievalType
	switch {
	// Receieved a Normal Retrieval Message (Lookup the Message ID)
	case bytes.Equal(c, common.ADRetrievalNormal):
		mail := s.Delegate.RetrieveMessageForUser(retrieval.GetMessageId(), common.CreateADAddress(retrieval.GetFromAddress()))

		if mail == nil {
			// If there is no message stored with that ID, then send back an error
			common.CreateErrorMessage("400", "no message for that id and user").SendToConnection(conn, s.Key)
			return
		}

		// If it passes these checks, send the message back through the connection
		message, err := mail.Marshal(retrievalMessage.FromAddress, s.Key, s.TrackerList)
		if err != nil {
			s.handleError("Handle Client (Marshalling Return Message)", err)
			return
		}

		message.SendToConnection(conn, s.Key)

	// Received a Public Retrieval Message (Return all Messages Since the Date Provided)
	case bytes.Equal(c, common.ADRetrievalPublic):

		output := s.Delegate.RetrievePublic(common.CreateADAddress(retrieval.GetFromAddress()), retrieval.GetSinceDate())

		if len(output) == 0 {
			common.CreateErrorMessage("400", "No public messages for that address").SendToConnection(conn, s.Key)
			return
		}

		// Alert the Client that an Array is Coming
		arrayData, err := common.CreateArrayedMessage(uint32(len(output)))
		if err != nil {
			s.handleError("Handle Retrieval (Creating AD Message)", err)
			return
		}
		arrayData.SendToConnection(conn, s.Key)

		// Write all of the Data
		for _, v := range output {
			theMessage, _ := v.Marshal(retrievalMessage.FromAddress, s.Key, s.TrackerList)
			theMessage.SendToConnection(conn, s.Key)
		}

	// Received a Mine Retrieval Message (Return all Messages that are Stored - Since the Date Provided)
	case bytes.Equal(c, common.ADRetrievalMine):
		output := s.Delegate.RetrieveInbox(common.CreateADAddress(retrieval.GetFromAddress()), retrieval.GetSinceDate())

		if len(output) == 0 {
			common.CreateErrorMessage("400", "no inbox messages for that address").SendToConnection(conn, s.Key)
			return
		}

		arrayData, err := common.CreateArrayedMessage(uint32(len(output)))
		if err != nil {
			s.handleError("Handle Retrieval (Creating AD Message)", err)
			return
		}

		arrayData.SendToConnection(conn, s.Key)

		// Write all of the Data
		for _, v := range output {
			v.ADMessage.SendToConnection(conn, s.Key)
		}

	default:
		s.handleError("Handle Retrieval", errors.New("Invalid Retrieval Type"))
	}
}

// Function that Handles a Request to Send a Message
func (s *Server) handleSendRequest(request *airdispatch.SendMailRequest, fromAddr *common.ADAddress) {
	theMessage, err := common.CreateADMessageFromBytes(request.GetStoredMessage())
	if err != nil {
		s.handleError("Handle Send Request (Reading ADMessage from Send Request)", err)
		return
	}

	theMail, err := common.CreateADMailFromADMessage(theMessage, nil)
	if err != nil {
		s.handleError("Handle Send Request (Reading ADMail from ADMessage)", err)
		return
	}

	// Check to see if it a public message or not
	if len(request.ToAddress) != 0 && request.ToAddress[0] != fromAddr.ToString() && request.ToAddress[0] != "" {
		hash := s.Delegate.SavePrivateMail(theMail, request.ToAddress)

		for _, v := range request.ToAddress {
			s.SendAlert(hash, common.CreateADAddress(v))
		}

	} else {
		s.Delegate.SavePublicMail(theMail)
	}
}

// A function that delivers an alert to a location
func (s *Server) SendAlert(message_id string, toAddr *common.ADAddress) {
	// Populate the Alert message
	stringAddr := toAddr.ToString()
	newAlert := &airdispatch.Alert{
		ToAddress: &stringAddr,
		Location:  &s.LocationName,
		MessageId: &message_id,
	}
	alertData, _ := proto.Marshal(newAlert)

	// Create the Message to Send
	newMessage := &common.ADMessage{}
	newMessage.MessageType = common.ALERT_MESSAGE
	newMessage.Payload = alertData

	newMessage.SendToAddress(toAddr, s.Key, s.TrackerList)
}
