package server

import (
	adErrors "airdispat.ch/errors"
	"airdispat.ch/identity"
	"airdispat.ch/message"
	"airdispat.ch/routing"
	"airdispat.ch/wire"
	"errors"
	"net"
	"time"
)

// A structure that stores any errors generated by the Server framework
type ServerError struct {
	Location string
	Error    error
}

// This interface defines the functions that an
// Airdispatch server must respond to in order to properly function
type ServerDelegate interface {
	HandleError(err *ServerError)
	LogMessage(toLog ...string)

	SaveMessageDescription(*MessageDescription)

	IdentityForUser(addr *identity.Address) *identity.Identity

	RetrieveMessageForUser(id string, author *identity.Address, forAddr *identity.Address) (message *message.Mail)
	RetrieveMessageListForUser(since uint64, author *identity.Address, forAddr *identity.Address) (messages *MessageList)
}

// The server structure tahat holds all of the necessary instance variables
type Server struct {
	LocationName string
	Key          *identity.Identity
	Delegate     ServerDelegate
	Router       routing.Router
}

// Function that starts the server on a specific port
func (s *Server) StartServer(port string) error {
	// Resolve the Address of the Server
	service := ":" + port
	tcpAddr, _ := net.ResolveTCPAddr("tcp4", service)
	s.Delegate.LogMessage("Starting Server on " + service)

	// Start the Server
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		return err
	}

	s.serverLoop(listener)
	return nil
}

// Sends an error to the Server Delegate
func (s *Server) handleError(location string, error error) {
	s.Delegate.HandleError(&ServerError{
		Location: location,
		Error:    error,
	})
}

// The loop that continues while waiting on clients to connect
func (s *Server) serverLoop(listener *net.TCPListener) {
	// Loop forever, waiting for connections
	for {
		// Accept a Connection
		conn, err := listener.Accept()
		if err != nil {
			s.handleError("Server Loop (Accepting New Client)", err)
			continue
		}

		// Concurrently handle the connection
		go s.handleClient(conn)
	}
}

// Called when a client connects
func (s *Server) handleClient(conn net.Conn) {
	s.Delegate.LogMessage("Serving", conn.RemoteAddr().String())
	tNow := time.Now()
	defer s.Delegate.LogMessage("Finished with", conn.RemoteAddr().String(), "in", time.Since(tNow).String())

	// Close the Connection after Handling
	defer conn.Close()

	// Read in the Message
	newMessage, err := message.ReadMessageFromConnection(conn)
	if err != nil {
		// There is nothing we can do if we can't read the message.
		s.handleError("Read Message From Connection", err)
		adErrors.CreateError(adErrors.UnexpectedError, "Unable to read message properly.", s.Key.Address).Send(s.Key, conn)
		return
	}

	decryptor := s.Key
	if newMessage.To.String() != s.Key.Address.String() {
		decryptor = s.Delegate.IdentityForUser(newMessage.To)
	}
	if decryptor == nil {
		// Unable to decrypt message shouldn't end up being an error.
		s.handleError("Decrypt Message", errors.New("Unable to find decryption key for message."))
		adErrors.CreateError(adErrors.AddressNotFound, "Unable to find decryption key for message.", s.Key.Address).Send(s.Key, conn)
		return
	}

	signedMessage, err := newMessage.Decrypt(decryptor)
	if err != nil {
		s.handleError("Decrypt Message", err)
		adErrors.CreateError(adErrors.UnexpectedError, "Unable to properly decrypt message.", s.Key.Address).Send(s.Key, conn)
		return
	}

	if !signedMessage.Verify() {
		s.handleError("Verify Signature", errors.New("Unable to Verify Signature on Message"))
		adErrors.CreateError(adErrors.InvalidSignature, "Signature is invalid.", s.Key.Address).Send(s.Key, conn)
		return
	}

	data, mesType, h, err := signedMessage.ReconstructMessage()

	if err != nil {
		s.handleError("Verifying Message Structure", err)
		adErrors.CreateError(adErrors.UnexpectedError, "Unable to verify message structure.", s.Key.Address).Send(s.Key, conn)
		return
	}

	// Switch based on the Message Type
	switch mesType {
	case wire.MessageDescriptionCode:
		s.handleMessageDescription(data, h, conn)
	case wire.TransferMessageCode:
		s.handleTransferMessage(data, h, conn)
	case wire.TransferMessageListCode:
		s.handleTransferMessageList(data, h, conn)
	}
}

func (s *Server) handleMessageDescription(desc []byte, h message.Header, conn net.Conn) {
	description, err := CreateMessageDescriptionFromBytes(desc, h)
	if err != nil {
		adErrors.CreateError(adErrors.UnexpectedError, "Unable to unpack message description.", s.Key.Address).Send(s.Key, conn)
		return
	}

	s.Delegate.SaveMessageDescription(description)
}

// Function that Handles a DataRetrieval Message
func (s *Server) handleTransferMessage(desc []byte, h message.Header, conn net.Conn) {
	txMessage, err := CreateTransferMessageFromBytes(desc, h)
	if err != nil {
		adErrors.CreateError(adErrors.UnexpectedError, "Unable to unpack transfer message.", s.Key.Address).Send(s.Key, conn)
		return
	}
	fromIdentity := s.Delegate.IdentityForUser(txMessage.h.To)
	if fromIdentity == nil {
		s.handleError("Loading Identity for User.", errors.New("User doesn't live here."))
		adErrors.CreateError(adErrors.AddressNotFound, "You cannot download messages for users that do not reside on this server.", s.Key.Address).Send(s.Key, conn)
		return
	}

	mail := s.Delegate.RetrieveMessageForUser(txMessage.Name, txMessage.h.To, txMessage.h.From)
	if mail == nil {
		s.handleError("Loading message from Server", errors.New("Couldn't find message"))
		adErrors.CreateError(adErrors.MessageNotFound, "That message doesn't exist.", s.Key.Address).Send(s.Key, conn)
		return
	}

	newAddr, err := s.Router.Lookup(txMessage.h.From.String())
	if err != nil {
		s.handleError("Looking up address to return...", err)
		adErrors.CreateError(adErrors.UnexpectedError, "Couldn't locate user to return message to.", s.Key.Address).Send(s.Key, conn)
		return
	}

	err = message.SignAndSendToConnection(mail, fromIdentity, newAddr, conn)
	if err != nil {
		s.handleError("Sign and Send Mail", err)
		adErrors.CreateError(adErrors.InternalError, "Unable to pack return message.", s.Key.Address).Send(s.Key, conn)
		return
	}
}

func (s *Server) handleTransferMessageList(desc []byte, h message.Header, conn net.Conn) {
	txMessage, err := CreateTransferMessageListFromBytes(desc, h)
	if err != nil {
		adErrors.CreateError(adErrors.UnexpectedError, "Unable to unpack transfer message list.", s.Key.Address).Send(s.Key, conn)
		return
	}

	fromIdentity := s.Delegate.IdentityForUser(txMessage.h.To)
	if fromIdentity == nil {
		s.handleError("Loading Identity for User.", errors.New("User doesn't live here."))
		adErrors.CreateError(adErrors.AddressNotFound, "Couldn't find a user by that address.", s.Key.Address).Send(s.Key, conn)
		return
	}

	mail := s.Delegate.RetrieveMessageListForUser(txMessage.Since, txMessage.h.To, txMessage.h.From)
	if mail == nil {
		s.handleError("Loading message from Server", errors.New("Couldn't find message"))
		adErrors.CreateError(adErrors.MessageNotFound, "Couldn't find any messages for that user.", s.Key.Address).Send(s.Key, conn)
		return
	}

	newAddr, err := s.Router.Lookup(txMessage.h.From.String())
	if err != nil {
		s.handleError("Looking up address to return...", err)
		adErrors.CreateError(adErrors.UnexpectedError, "Couldn't find return address for user.", s.Key.Address).Send(s.Key, conn)
		return
	}

	err = message.SignAndSendToConnection(mail, fromIdentity, newAddr, conn)
	if err != nil {
		s.handleError("Sign and Send Mail List", err)
		adErrors.CreateError(adErrors.InternalError, "Couldn't pack return mail list.", s.Key.Address).Send(s.Key, conn)
		return
	}
}
