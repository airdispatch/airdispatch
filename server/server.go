package server

import (
	"airdispat.ch/identity"
	"airdispat.ch/message"
	"airdispat.ch/wire"
	"errors"
	"net"
)

// A structure that stores any errors generated by the Server framework
type ServerError struct {
	Location string
	Error    error
}

// This interface defines the functions that an
// Airdispatch server must respond to in order to properly function
type ServerDelegate interface {
	HandleError(err *ServerError)
	LogMessage(toLog string)

	SaveMessageDescription(*MessageDescription)

	IdentityForUser(addr *identity.Address) *identity.Identity

	RetrieveMessageForUser(id string, addr *identity.Address) (message *message.EncryptedMessage)
	RetrieveMessageListForUser(since uint64, fromAddr *identity.Address) (messages *message.EncryptedMessage)
}

// The server structure tahat holds all of the necessary instance variables
type Server struct {
	LocationName string
	// TrackerList  *common.ADTrackerList
	Key      *identity.Identity
	Delegate ServerDelegate
}

// Function that starts the server on a specific port
func (s *Server) StartServer(port string) error {
	// Resolve the Address of the Server
	service := ":" + port
	tcpAddr, _ := net.ResolveTCPAddr("tcp4", service)
	s.Delegate.LogMessage("Starting Server on " + service)

	// Start the Server
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		return err
	}
	s.Delegate.LogMessage("Server is Running...")

	s.serverLoop(listener)
	return nil
}

// Sends an error to the Server Delegate
func (s *Server) handleError(location string, error error) {
	s.Delegate.HandleError(&ServerError{
		Location: location,
		Error:    error,
	})
}

// The loop that continues while waiting on clients to connect
func (s *Server) serverLoop(listener *net.TCPListener) {
	// Loop forever, waiting for connections
	for {
		// Accept a Connection
		conn, err := listener.Accept()
		if err != nil {
			s.handleError("Server Loop (Accepting New Client)", err)
			continue
		}

		// Concurrently handle the connection
		go s.handleClient(conn)
	}
}

// Called when a client connects
func (s *Server) handleClient(conn net.Conn) {
	// Close the Connection after Handling
	defer conn.Close()

	// Read in the Message
	newMessage, err := message.ReadMessageFromConnection(conn)
	if err != nil {
		s.handleError("Read Message From Connection", err)
		return
	}

	var decryptor = s.Key
	if newMessage.To.String() != s.Key.Address.String() {
		decryptor = s.Delegate.IdentityForUser(newMessage.To)
	}

	signedMessage, err := newMessage.Decrypt(decryptor)
	if err != nil {
		s.handleError("Decrypt Message", err)
		return
	}

	if !signedMessage.Verify() {
		s.handleError("Verify Signature", errors.New("Unable to Verify Signature on Message"))
		return
	}

	data, mesType, h, err := signedMessage.ReconstructMessage()

	if newMessage.To.String() != h.To.String() { //|| signedMessage.SigningKey != h.From.String() {
		s.handleError("Verifying Message Structure", errors.New("Unable to Verify Message Structure"))
		return
	}

	// Switch based on the Message Type
	switch mesType {
	case wire.MessageDescriptionCode:
		s.handleMessageDescription(data, h)
	case wire.TransferMessageCode:
		s.handleTransferMessage(data, h, conn)
	case wire.TransferMessageListCode:
		s.handleTransferMessageList(data, h, conn)
	}
}

func (s *Server) handleMessageDescription(desc []byte, h message.Header) {
	description, err := CreateMessageDescriptionFromBytes(desc, h)
	if err != nil {
		return
	}

	s.Delegate.SaveMessageDescription(description)
}

// Function that Handles a DataRetrieval Message
func (s *Server) handleTransferMessage(desc []byte, h message.Header, conn net.Conn) {
	txMessage, err := CreateTransferMessageFromBytes(desc, h)
	if err != nil {
		return
	}

	mail := s.Delegate.RetrieveMessageForUser(txMessage.Name, txMessage.h.From)
	if mail == nil {
		// If there is no message stored with that ID, then send back an error
		// common.CreateErrorMessage("400", "no message for that id and user").SendToConnection(conn, s.Key)
		return
	}
	mail.SendMessageToConnection(conn)
}

func (s *Server) handleTransferMessageList(desc []byte, h message.Header, conn net.Conn) {
	txMessage, err := CreateTransferMessageListFromBytes(desc, h)
	if err != nil {
		return
	}

	mail := s.Delegate.RetrieveMessageListForUser(txMessage.Since, txMessage.h.To)
	if mail == nil {
		return
	}

	mail.SendMessageToConnection(conn)
}

// A function that delivers an alert to a location
// func (s *Server) SendAlert(message_id string, toAddr *common.ADAddress) {
// 	// Populate the Alert message
// 	stringAddr := toAddr.ToString()
// 	newAlert := &airdispatch.Alert{
// 		ToAddress: &stringAddr,
// 		Location:  &s.LocationName,
// 		MessageId: &message_id,
// 	}
// 	alertData, _ := proto.Marshal(newAlert)

// 	// Create the Message to Send
// 	newMessage := &common.ADMessage{}
// 	newMessage.MessageType = common.ALERT_MESSAGE
// 	newMessage.Payload = alertData

// 	newMessage.SendToAddress(toAddr, s.Key, s.TrackerList)
// }
