package server

import (
	"airdispat.ch/identity"
	"airdispat.ch/message"
	"airdispat.ch/routing"
	"airdispat.ch/wire"
	"errors"
	"net"
	"time"
)

// A structure that stores any errors generated by the Server framework
type ServerError struct {
	Location string
	Error    error
}

// This interface defines the functions that an
// Airdispatch server must respond to in order to properly function
type ServerDelegate interface {
	HandleError(err *ServerError)
	LogMessage(toLog ...string)

	SaveMessageDescription(desc *message.EncryptedMessage)

	RetrieveMessageForUser(id string, author *identity.Address, forAddr *identity.Address) *message.EncryptedMessage
	RetrieveMessageListForUser(since uint64, author *identity.Address, forAddr *identity.Address) []*message.EncryptedMessage
}

// The server structure tahat holds all of the necessary instance variables
type Server struct {
	LocationName string
	Key          *identity.Identity
	Delegate     ServerDelegate
	Router       routing.Router
}

// Function that starts the server on a specific port
func (s *Server) StartServer(port string) error {
	// Resolve the Address of the Server
	service := ":" + port
	tcpAddr, _ := net.ResolveTCPAddr("tcp4", service)
	s.Delegate.LogMessage("Starting Server on " + service)

	// Start the Server
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		return err
	}

	s.serverLoop(listener)
	return nil
}

// Sends an error to the Server Delegate
func (s *Server) handleError(location string, error error) {
	s.Delegate.HandleError(&ServerError{
		Location: location,
		Error:    error,
	})
}

// The loop that continues while waiting on clients to connect
func (s *Server) serverLoop(listener *net.TCPListener) {
	// Loop forever, waiting for connections
	for {
		// Accept a Connection
		conn, err := listener.Accept()
		if err != nil {
			s.handleError("Server Loop (Accepting New Client)", err)
			continue
		}

		// Concurrently handle the connection
		go s.handleClient(conn)
	}
}

// Called when a client connects
func (s *Server) handleClient(conn net.Conn) {
	s.Delegate.LogMessage("Serving", conn.RemoteAddr().String())
	tNow := time.Now()
	defer s.Delegate.LogMessage("Finished with", conn.RemoteAddr().String(), "in", time.Since(tNow).String())

	// Close the Connection after Handling
	defer conn.Close()

	// Read in the Message
	newMessage, err := message.ReadMessageFromConnection(conn)
	if err != nil {
		s.handleError("Read Message From Connection", err)
		return
	}

	if newMessage.To.String() == s.Key.Address.String() || newMessage.To.IsPublic() {
		signedMessage, err := newMessage.Decrypt(s.Key)
		if err != nil {
			s.handleError("Decrypt Message", err)
			return
		}

		if !signedMessage.Verify() {
			s.handleError("Verify Signature", errors.New("Unable to Verify Signature on Message"))
			return
		}

		data, mesType, h, err := signedMessage.ReconstructMessage()

		if err != nil {
			s.handleError("Verifying Message Structure", err)
			return
		}

		// Switch based on the Message Type
		switch mesType {
		case wire.TransferMessageCode:
			s.handleTransferMessage(data, h, conn)
		case wire.TransferMessageListCode:
			s.handleTransferMessageList(data, h, conn)
		}
	} else {
		s.handleMessageDescription(newMessage)
	}
}

// Send the Message to the Delegate
func (s *Server) handleMessageDescription(desc *message.EncryptedMessage) {
	s.Delegate.SaveMessageDescription(desc)
}

// Function that Handles a DataRetrieval Message
func (s *Server) handleTransferMessage(desc []byte, h message.Header, conn net.Conn) {
	txMessage, err := CreateTransferMessageFromBytes(desc, h)
	if err != nil {
		return
	}

	mail := s.Delegate.RetrieveMessageForUser(txMessage.Name, txMessage.h.To, txMessage.h.From)
	if mail == nil {
		s.handleError("Loading message from Server", errors.New("Couldn't find message"))
		// If there is no message stored with that ID, then send back an error
		// common.CreateErrorMessage("400", "no message for that id and user").SendToConnection(conn, s.Key)
		return
	}

	err = mail.SendMessageToConnection(conn)
	if err != nil {
		s.handleError("Sign and Send Mail", err)
		return
	}
}

func (s *Server) handleTransferMessageList(desc []byte, h message.Header, conn net.Conn) {
	txMessage, err := CreateTransferMessageListFromBytes(desc, h)
	if err != nil {
		return
	}

	mail := s.Delegate.RetrieveMessageListForUser(txMessage.Since, txMessage.h.To, txMessage.h.From)
	if mail == nil {
		s.handleError("Loading message from Server", errors.New("Couldn't find message"))
		return
	}

	ml := &MessageList{
		Length: uint64(len(mail)),
		h: message.CreateHeader(s.Key.Address, txMessage.h.From),
	}

	err = message.SignAndSendToConnection(ml, s.Key, txMessage.h.From, conn)
	if err != nil {
		s.handleError("Sending message list to connection.", err)
		return
	}

	for _, v := range mail {
		err := v.SendMessageToConnection(conn)
		if err != nil {
				s.handleError("Sending public message to connection.", err)
		}
	}
}
